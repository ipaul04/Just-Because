{"ast":null,"code":"var _jsxFileName = \"/Users/irenepaul/Documents/GitHub/Just-Because/Just_Because/src/BackgroundSlideshow.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { motion, useAnimation } from 'framer-motion';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ANIMATION_DURATION = 0.8; // Seconds for one slide animation\nconst MOVE_INTERVAL = 1.5; // Time between moves in seconds\nconst CARD_GAP = 10; // Gap between cards in pixels\n\nexport default function BackgroundSlideshow({\n  images\n}) {\n  _s();\n  const controls = useAnimation();\n  const [cardData, setCardData] = useState([]);\n  const imageIndexRef = useRef(0);\n  const nextCardId = useRef(0);\n  const [gridRows, setGridRows] = useState(0);\n  const [gridCols, setGridCols] = useState(0);\n  const [cardDimension, setCardDimension] = useState(0);\n  const calculateGridDimensions = useCallback(() => {\n    const minCardDimension = 150; // Minimum size for a card\n    const maxCardDimension = 250; // Maximum size for a card\n\n    const availableWidth = window.innerWidth;\n    const availableHeight = window.innerHeight;\n    let calculatedCardDimension = minCardDimension;\n    let calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    let calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Try to increase card dimension if there's extra space\n    if (calculatedGridCols > 0 && calculatedGridRows > 0) {\n      const potentialCardDimensionX = Math.floor(availableWidth / calculatedGridCols - CARD_GAP);\n      const potentialCardDimensionY = Math.floor(availableHeight / calculatedGridRows - CARD_GAP);\n      calculatedCardDimension = Math.min(maxCardDimension, Math.max(minCardDimension, Math.min(potentialCardDimensionX, potentialCardDimensionY)));\n    }\n\n    // Recalculate rows and cols with the (potentially) new card dimension\n    calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Ensure at least one row and column\n    if (calculatedGridCols === 0) calculatedGridCols = 1;\n    if (calculatedGridRows === 0) calculatedGridRows = 1;\n    setCardDimension(calculatedCardDimension);\n    setGridCols(calculatedGridCols);\n    setGridRows(calculatedGridRows);\n    return {\n      calculatedGridRows,\n      calculatedGridCols,\n      calculatedCardDimension\n    };\n  }, []);\n  useEffect(() => {\n    const {\n      calculatedGridRows,\n      calculatedGridCols,\n      calculatedCardDimension\n    } = calculateGridDimensions();\n    const initialCards = Array.from({\n      length: calculatedGridRows * calculatedGridCols\n    }, (_, i) => ({\n      id: nextCardId.current++,\n      image: images[imageIndexRef.current++ % images.length],\n      position: {\n        row: Math.floor(i / calculatedGridCols),\n        col: i % calculatedGridCols\n      },\n      key: `card-${nextCardId.current - 1}`\n    }));\n    setCardData(initialCards);\n    const animateGrid = async () => {\n      while (true) {\n        await new Promise(resolve => setTimeout(resolve, MOVE_INTERVAL * 1000));\n        const isRow = Math.random() > 0.5;\n        const indexToAnimate = isRow ? Math.floor(Math.random() * calculatedGridRows) : Math.floor(Math.random() * calculatedGridCols);\n        const direction = Math.random() > 0.5 ? 1 : -1; // 1 for forward (right/down), -1 for backward (left/up)\n\n        setCardData(prevCards => {\n          const newCards = [...prevCards];\n          const affectedCards = newCards.filter(card => isRow ? card.position.row === indexToAnimate : card.position.col === indexToAnimate);\n\n          // Sort cards to ensure consistent movement (e.g., for a b c -> c a b)\n          affectedCards.sort((a, b) => isRow ? a.position.col - b.position.col : a.position.row - b.position.row);\n          const movedCard = direction === 1 ? affectedCards[affectedCards.length - 1] : affectedCards[0];\n          affectedCards.forEach(card => {\n            if (card.id === movedCard.id) {\n              // This card will move to the other end of the line\n              if (isRow) {\n                card.position.col = direction === 1 ? 0 : calculatedGridCols - 1;\n              } else {\n                card.position.row = direction === 1 ? 0 : calculatedGridRows - 1;\n              }\n            } else {\n              // Other cards shift their positions\n              if (isRow) {\n                card.position.col = (card.position.col + direction + calculatedGridCols) % calculatedGridCols;\n              } else {\n                card.position.row = (card.position.row + direction + calculatedGridRows) % calculatedGridRows;\n              }\n            }\n            // Update image for the card that moved to the 'new' position\n            if (card.id === movedCard.id) {\n              card.image = images[imageIndexRef.current++ % images.length];\n            }\n          });\n          return newCards;\n        });\n      }\n    };\n    animateGrid();\n  }, [images, controls, calculateGridDimensions]);\n  useEffect(() => {\n    window.addEventListener('resize', calculateGridDimensions);\n    return () => window.removeEventListener('resize', calculateGridDimensions);\n  }, [calculateGridDimensions]);\n  if (gridRows === 0 || gridCols === 0 || cardDimension === 0) {\n    return null; // Don't render until dimensions are calculated\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"absolute inset-0 z-0 overflow-hidden bg-gray-900 flex items-center justify-center\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"relative grid\",\n      style: {\n        gridTemplateColumns: `repeat(${gridCols}, ${cardDimension}px)`,\n        gridTemplateRows: `repeat(${gridRows}, ${cardDimension}px)`,\n        width: gridCols * cardDimension + (gridCols - 1) * CARD_GAP,\n        height: gridRows * cardDimension + (gridRows - 1) * CARD_GAP,\n        gap: CARD_GAP\n      },\n      children: cardData.map(card => /*#__PURE__*/_jsxDEV(motion.div, {\n        layout: true,\n        transition: {\n          duration: ANIMATION_DURATION,\n          ease: 'easeInOut'\n        },\n        className: \"relative bg-white rounded-lg shadow-lg flex items-center justify-center p-2 overflow-hidden\",\n        style: {\n          gridColumn: card.position.col + 1,\n          gridRow: card.position.row + 1\n        },\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: card.image,\n          alt: \"Slideshow Card\",\n          className: \"w-full h-full object-cover rounded-md\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 155,\n          columnNumber: 13\n        }, this)\n      }, card.key, false, {\n        fileName: _jsxFileName,\n        lineNumber: 145,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute inset-0 bg-black opacity-50 z-10\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 159,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 133,\n    columnNumber: 5\n  }, this);\n}\n_s(BackgroundSlideshow, \"pDc0hRK9YtbkaW89VG/DKCjbyDU=\", false, function () {\n  return [useAnimation];\n});\n_c = BackgroundSlideshow;\nvar _c;\n$RefreshReg$(_c, \"BackgroundSlideshow\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","motion","useAnimation","jsxDEV","_jsxDEV","ANIMATION_DURATION","MOVE_INTERVAL","CARD_GAP","BackgroundSlideshow","images","_s","controls","cardData","setCardData","imageIndexRef","nextCardId","gridRows","setGridRows","gridCols","setGridCols","cardDimension","setCardDimension","calculateGridDimensions","minCardDimension","maxCardDimension","availableWidth","window","innerWidth","availableHeight","innerHeight","calculatedCardDimension","calculatedGridCols","Math","floor","calculatedGridRows","potentialCardDimensionX","potentialCardDimensionY","min","max","initialCards","Array","from","length","_","i","id","current","image","position","row","col","key","animateGrid","Promise","resolve","setTimeout","isRow","random","indexToAnimate","direction","prevCards","newCards","affectedCards","filter","card","sort","a","b","movedCard","forEach","addEventListener","removeEventListener","className","children","style","gridTemplateColumns","gridTemplateRows","width","height","gap","map","div","layout","transition","duration","ease","gridColumn","gridRow","src","alt","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/irenepaul/Documents/GitHub/Just-Because/Just_Because/src/BackgroundSlideshow.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { motion, useAnimation } from 'framer-motion';\n\ninterface BackgroundSlideshowProps {\n  images: string[];\n}\n\nconst ANIMATION_DURATION = 0.8; // Seconds for one slide animation\nconst MOVE_INTERVAL = 1.5; // Time between moves in seconds\nconst CARD_GAP = 10; // Gap between cards in pixels\n\ninterface Card {\n  id: number;\n  image: string;\n  position: { row: number; col: number };\n  key: string; // Unique key for Framer Motion's AnimatePresence\n}\n\nexport default function BackgroundSlideshow({ images }: BackgroundSlideshowProps) {\n  const controls = useAnimation();\n  const [cardData, setCardData] = useState<Card[]>([]);\n  const imageIndexRef = useRef(0);\n  const nextCardId = useRef(0);\n  const [gridRows, setGridRows] = useState(0);\n  const [gridCols, setGridCols] = useState(0);\n  const [cardDimension, setCardDimension] = useState(0);\n\n  const calculateGridDimensions = useCallback(() => {\n    const minCardDimension = 150; // Minimum size for a card\n    const maxCardDimension = 250; // Maximum size for a card\n\n    const availableWidth = window.innerWidth;\n    const availableHeight = window.innerHeight;\n\n    let calculatedCardDimension = minCardDimension;\n    let calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    let calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Try to increase card dimension if there's extra space\n    if (calculatedGridCols > 0 && calculatedGridRows > 0) {\n      const potentialCardDimensionX = Math.floor((availableWidth / calculatedGridCols) - CARD_GAP);\n      const potentialCardDimensionY = Math.floor((availableHeight / calculatedGridRows) - CARD_GAP);\n      calculatedCardDimension = Math.min(maxCardDimension, Math.max(minCardDimension, Math.min(potentialCardDimensionX, potentialCardDimensionY)));\n    }\n\n    // Recalculate rows and cols with the (potentially) new card dimension\n    calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Ensure at least one row and column\n    if (calculatedGridCols === 0) calculatedGridCols = 1;\n    if (calculatedGridRows === 0) calculatedGridRows = 1;\n\n    setCardDimension(calculatedCardDimension);\n    setGridCols(calculatedGridCols);\n    setGridRows(calculatedGridRows);\n\n    return { calculatedGridRows, calculatedGridCols, calculatedCardDimension };\n  }, []);\n\n  useEffect(() => {\n    const { calculatedGridRows, calculatedGridCols, calculatedCardDimension } = calculateGridDimensions();\n\n    const initialCards: Card[] = Array.from({ length: calculatedGridRows * calculatedGridCols }, (_, i) => ({\n      id: nextCardId.current++,\n      image: images[imageIndexRef.current++ % images.length],\n      position: { row: Math.floor(i / calculatedGridCols), col: i % calculatedGridCols },\n      key: `card-${nextCardId.current - 1}`,\n    }));\n    setCardData(initialCards);\n\n    const animateGrid = async () => {\n      while (true) {\n        await new Promise(resolve => setTimeout(resolve, MOVE_INTERVAL * 1000));\n\n        const isRow = Math.random() > 0.5;\n        const indexToAnimate = isRow ? Math.floor(Math.random() * calculatedGridRows) : Math.floor(Math.random() * calculatedGridCols);\n        const direction = Math.random() > 0.5 ? 1 : -1; // 1 for forward (right/down), -1 for backward (left/up)\n\n        setCardData(prevCards => {\n          const newCards = [...prevCards];\n          const affectedCards = newCards.filter(card => \n            isRow ? card.position.row === indexToAnimate : card.position.col === indexToAnimate\n          );\n\n          // Sort cards to ensure consistent movement (e.g., for a b c -> c a b)\n          affectedCards.sort((a, b) => \n            isRow ? a.position.col - b.position.col : a.position.row - b.position.row\n          );\n\n          const movedCard = direction === 1 ? affectedCards[affectedCards.length - 1] : affectedCards[0];\n\n          affectedCards.forEach(card => {\n            if (card.id === movedCard.id) {\n              // This card will move to the other end of the line\n              if (isRow) {\n                card.position.col = direction === 1 ? 0 : calculatedGridCols - 1;\n              } else {\n                card.position.row = direction === 1 ? 0 : calculatedGridRows - 1;\n              }\n            } else {\n              // Other cards shift their positions\n              if (isRow) {\n                card.position.col = (card.position.col + direction + calculatedGridCols) % calculatedGridCols;\n              } else {\n                card.position.row = (card.position.row + direction + calculatedGridRows) % calculatedGridRows;\n              }\n            }\n            // Update image for the card that moved to the 'new' position\n            if (card.id === movedCard.id) {\n                card.image = images[imageIndexRef.current++ % images.length];\n            }\n          });\n\n          return newCards;\n        });\n      }\n    };\n\n    animateGrid();\n  }, [images, controls, calculateGridDimensions]);\n\n  useEffect(() => {\n    window.addEventListener('resize', calculateGridDimensions);\n    return () => window.removeEventListener('resize', calculateGridDimensions);\n  }, [calculateGridDimensions]);\n\n  if (gridRows === 0 || gridCols === 0 || cardDimension === 0) {\n    return null; // Don't render until dimensions are calculated\n  }\n\n  return (\n    <div className=\"absolute inset-0 z-0 overflow-hidden bg-gray-900 flex items-center justify-center\">\n      <div\n        className=\"relative grid\"\n        style={{\n          gridTemplateColumns: `repeat(${gridCols}, ${cardDimension}px)`,\n          gridTemplateRows: `repeat(${gridRows}, ${cardDimension}px)`,\n          width: gridCols * cardDimension + (gridCols - 1) * CARD_GAP,\n          height: gridRows * cardDimension + (gridRows - 1) * CARD_GAP,\n          gap: CARD_GAP,\n        }}\n      >\n        {cardData.map((card) => (\n          <motion.div\n            key={card.key}\n            layout\n            transition={{ duration: ANIMATION_DURATION, ease: 'easeInOut' }}\n            className=\"relative bg-white rounded-lg shadow-lg flex items-center justify-center p-2 overflow-hidden\"\n            style={{\n              gridColumn: card.position.col + 1,\n              gridRow: card.position.row + 1,\n            }}\n          >\n            <img src={card.image} alt=\"Slideshow Card\" className=\"w-full h-full object-cover rounded-md\" />\n          </motion.div>\n        ))}\n      </div>\n      <div className=\"absolute inset-0 bg-black opacity-50 z-10\"></div>\n    </div>\n  );\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}