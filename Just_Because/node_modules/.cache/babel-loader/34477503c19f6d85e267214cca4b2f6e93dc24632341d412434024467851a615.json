{"ast":null,"code":"var _jsxFileName = \"/Users/irenepaul/Documents/GitHub/Just-Because/Just_Because/src/BackgroundSlideshow.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { motion, useAnimation } from 'framer-motion';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ANIMATION_DURATION = 0.8; // Seconds for one slide animation\nconst MOVE_INTERVAL = 1.5; // Time between moves in seconds\nconst CARD_GAP = 10; // Gap between cards in pixels\n\nexport default function BackgroundSlideshow({\n  images\n}) {\n  _s();\n  const controls = useAnimation();\n  const [cardData, setCardData] = useState([]);\n  const imageIndexRef = useRef(0);\n  const nextCardId = useRef(0);\n  const [gridRows, setGridRows] = useState(0);\n  const [gridCols, setGridCols] = useState(0);\n  const [cardDimension, setCardDimension] = useState(0);\n  const calculateGridDimensions = useCallback(() => {\n    const minCardDimension = 150; // Minimum size for a card\n    const maxCardDimension = 250; // Maximum size for a card\n\n    const availableWidth = window.innerWidth;\n    const availableHeight = window.innerHeight;\n    let calculatedCardDimension = minCardDimension;\n    let calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    let calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Try to increase card dimension if there's extra space\n    if (calculatedGridCols > 0 && calculatedGridRows > 0) {\n      const potentialCardDimensionX = Math.floor(availableWidth / calculatedGridCols - CARD_GAP);\n      const potentialCardDimensionY = Math.floor(availableHeight / calculatedGridRows - CARD_GAP);\n      calculatedCardDimension = Math.min(maxCardDimension, Math.max(minCardDimension, Math.min(potentialCardDimensionX, potentialCardDimensionY)));\n    }\n\n    // Recalculate rows and cols with the (potentially) new card dimension\n    calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Ensure at least one row and column\n    if (calculatedGridCols === 0) calculatedGridCols = 1;\n    if (calculatedGridRows === 0) calculatedGridRows = 1;\n    setCardDimension(calculatedCardDimension);\n    setGridCols(calculatedGridCols);\n    setGridRows(calculatedGridRows);\n    return {\n      calculatedGridRows,\n      calculatedGridCols,\n      calculatedCardDimension\n    };\n  }, []);\n  useEffect(() => {\n    const {\n      calculatedGridRows,\n      calculatedGridCols,\n      calculatedCardDimension\n    } = calculateGridDimensions();\n    const initialCards = Array.from({\n      length: calculatedGridRows * calculatedGridCols\n    }, (_, i) => ({\n      id: nextCardId.current++,\n      image: images[imageIndexRef.current++ % images.length],\n      position: {\n        row: Math.floor(i / calculatedGridCols),\n        col: i % calculatedGridCols\n      },\n      key: `card-${nextCardId.current - 1}`\n    }));\n    setCardData(initialCards);\n    const animateGrid = async () => {\n      while (true) {\n        await new Promise(resolve => setTimeout(resolve, MOVE_INTERVAL * 1000));\n        setCardData(prevCards => {\n          const newCards = [...prevCards];\n\n          // Animate all columns simultaneously\n          for (let col = 0; col < calculatedGridCols; col++) {\n            const colCards = newCards.filter(card => card.position.col === col);\n\n            // Sort cards by row to ensure consistent movement\n            colCards.sort((a, b) => a.position.row - b.position.row);\n\n            // Odd numbered columns (1st, 3rd, 5th... = indices 0, 2, 4...):\n            //   - Top div disappears and reappears at bottom\n            //   - All other divs shift up\n            // Even numbered columns (2nd, 4th, 6th... = indices 1, 3, 5...):\n            //   - Bottom div disappears and reappears at top\n            //   - All other divs shift down\n            const isOddColumn = col % 2 === 0; // Odd visual column (1st, 3rd, 5th...)\n\n            if (isOddColumn) {\n              // Odd columns: top disappears, reappears at bottom, others shift up\n              const topCard = colCards[0]; // Top card\n\n              colCards.forEach(card => {\n                if (card.id === topCard.id) {\n                  // Top card moves to bottom\n                  card.position.row = calculatedGridRows - 1;\n                  card.image = images[imageIndexRef.current++ % images.length];\n                } else {\n                  // All other cards shift up (row decreases)\n                  card.position.row = card.position.row - 1;\n                }\n              });\n            } else {\n              // Even columns: bottom disappears, reappears at top, others shift down\n              const bottomCard = colCards[colCards.length - 1]; // Bottom card\n\n              colCards.forEach(card => {\n                if (card.id === bottomCard.id) {\n                  // Bottom card moves to top\n                  card.position.row = 0;\n                  card.image = images[imageIndexRef.current++ % images.length];\n                } else {\n                  // All other cards shift down (row increases)\n                  card.position.row = card.position.row + 1;\n                }\n              });\n            }\n          }\n          return newCards;\n        });\n      }\n    };\n    animateGrid();\n  }, [images, controls, calculateGridDimensions]);\n  useEffect(() => {\n    window.addEventListener('resize', calculateGridDimensions);\n    return () => window.removeEventListener('resize', calculateGridDimensions);\n  }, [calculateGridDimensions]);\n  if (gridRows === 0 || gridCols === 0 || cardDimension === 0) {\n    return null; // Don't render until dimensions are calculated\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"absolute inset-0 z-0 overflow-hidden bg-gray-900 flex items-center justify-center\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"relative grid\",\n      style: {\n        gridTemplateColumns: `repeat(${gridCols}, ${cardDimension}px)`,\n        gridTemplateRows: `repeat(${gridRows}, ${cardDimension}px)`,\n        width: gridCols * cardDimension + (gridCols - 1) * CARD_GAP,\n        height: gridRows * cardDimension + (gridRows - 1) * CARD_GAP,\n        gap: CARD_GAP\n      },\n      children: cardData.map(card => /*#__PURE__*/_jsxDEV(motion.div, {\n        layout: true,\n        transition: {\n          duration: ANIMATION_DURATION,\n          ease: 'easeInOut'\n        },\n        className: \"relative bg-white rounded-lg shadow-lg flex items-center justify-center p-2 overflow-hidden\",\n        style: {\n          gridColumn: card.position.col + 1,\n          gridRow: card.position.row + 1\n        },\n        children: /*#__PURE__*/_jsxDEV(\"img\", {\n          src: card.image,\n          alt: \"Slideshow Card\",\n          className: \"w-full h-full object-cover rounded-md\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 165,\n          columnNumber: 13\n        }, this)\n      }, card.key, false, {\n        fileName: _jsxFileName,\n        lineNumber: 155,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute inset-0 bg-black opacity-50 z-10\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 143,\n    columnNumber: 5\n  }, this);\n}\n_s(BackgroundSlideshow, \"pDc0hRK9YtbkaW89VG/DKCjbyDU=\", false, function () {\n  return [useAnimation];\n});\n_c = BackgroundSlideshow;\nvar _c;\n$RefreshReg$(_c, \"BackgroundSlideshow\");","map":{"version":3,"names":["React","useState","useEffect","useRef","useCallback","motion","useAnimation","jsxDEV","_jsxDEV","ANIMATION_DURATION","MOVE_INTERVAL","CARD_GAP","BackgroundSlideshow","images","_s","controls","cardData","setCardData","imageIndexRef","nextCardId","gridRows","setGridRows","gridCols","setGridCols","cardDimension","setCardDimension","calculateGridDimensions","minCardDimension","maxCardDimension","availableWidth","window","innerWidth","availableHeight","innerHeight","calculatedCardDimension","calculatedGridCols","Math","floor","calculatedGridRows","potentialCardDimensionX","potentialCardDimensionY","min","max","initialCards","Array","from","length","_","i","id","current","image","position","row","col","key","animateGrid","Promise","resolve","setTimeout","prevCards","newCards","colCards","filter","card","sort","a","b","isOddColumn","topCard","forEach","bottomCard","addEventListener","removeEventListener","className","children","style","gridTemplateColumns","gridTemplateRows","width","height","gap","map","div","layout","transition","duration","ease","gridColumn","gridRow","src","alt","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/irenepaul/Documents/GitHub/Just-Because/Just_Because/src/BackgroundSlideshow.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef, useCallback } from 'react';\nimport { motion, useAnimation } from 'framer-motion';\n\ninterface BackgroundSlideshowProps {\n  images: string[];\n}\n\nconst ANIMATION_DURATION = 0.8; // Seconds for one slide animation\nconst MOVE_INTERVAL = 1.5; // Time between moves in seconds\nconst CARD_GAP = 10; // Gap between cards in pixels\n\ninterface Card {\n  id: number;\n  image: string;\n  position: { row: number; col: number };\n  key: string; // Unique key for Framer Motion's AnimatePresence\n}\n\nexport default function BackgroundSlideshow({ images }: BackgroundSlideshowProps) {\n  const controls = useAnimation();\n  const [cardData, setCardData] = useState<Card[]>([]);\n  const imageIndexRef = useRef(0);\n  const nextCardId = useRef(0);\n  const [gridRows, setGridRows] = useState(0);\n  const [gridCols, setGridCols] = useState(0);\n  const [cardDimension, setCardDimension] = useState(0);\n\n  const calculateGridDimensions = useCallback(() => {\n    const minCardDimension = 150; // Minimum size for a card\n    const maxCardDimension = 250; // Maximum size for a card\n\n    const availableWidth = window.innerWidth;\n    const availableHeight = window.innerHeight;\n\n    let calculatedCardDimension = minCardDimension;\n    let calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    let calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Try to increase card dimension if there's extra space\n    if (calculatedGridCols > 0 && calculatedGridRows > 0) {\n      const potentialCardDimensionX = Math.floor((availableWidth / calculatedGridCols) - CARD_GAP);\n      const potentialCardDimensionY = Math.floor((availableHeight / calculatedGridRows) - CARD_GAP);\n      calculatedCardDimension = Math.min(maxCardDimension, Math.max(minCardDimension, Math.min(potentialCardDimensionX, potentialCardDimensionY)));\n    }\n\n    // Recalculate rows and cols with the (potentially) new card dimension\n    calculatedGridCols = Math.floor(availableWidth / (calculatedCardDimension + CARD_GAP));\n    calculatedGridRows = Math.floor(availableHeight / (calculatedCardDimension + CARD_GAP));\n\n    // Ensure at least one row and column\n    if (calculatedGridCols === 0) calculatedGridCols = 1;\n    if (calculatedGridRows === 0) calculatedGridRows = 1;\n\n    setCardDimension(calculatedCardDimension);\n    setGridCols(calculatedGridCols);\n    setGridRows(calculatedGridRows);\n\n    return { calculatedGridRows, calculatedGridCols, calculatedCardDimension };\n  }, []);\n\n  useEffect(() => {\n    const { calculatedGridRows, calculatedGridCols, calculatedCardDimension } = calculateGridDimensions();\n\n    const initialCards: Card[] = Array.from({ length: calculatedGridRows * calculatedGridCols }, (_, i) => ({\n      id: nextCardId.current++,\n      image: images[imageIndexRef.current++ % images.length],\n      position: { row: Math.floor(i / calculatedGridCols), col: i % calculatedGridCols },\n      key: `card-${nextCardId.current - 1}`,\n    }));\n    setCardData(initialCards);\n\n    const animateGrid = async () => {\n      while (true) {\n        await new Promise(resolve => setTimeout(resolve, MOVE_INTERVAL * 1000));\n\n        setCardData(prevCards => {\n          const newCards = [...prevCards];\n\n          // Animate all columns simultaneously\n          for (let col = 0; col < calculatedGridCols; col++) {\n            const colCards = newCards.filter(card => card.position.col === col);\n\n            // Sort cards by row to ensure consistent movement\n            colCards.sort((a, b) => a.position.row - b.position.row);\n\n            // Odd numbered columns (1st, 3rd, 5th... = indices 0, 2, 4...):\n            //   - Top div disappears and reappears at bottom\n            //   - All other divs shift up\n            // Even numbered columns (2nd, 4th, 6th... = indices 1, 3, 5...):\n            //   - Bottom div disappears and reappears at top\n            //   - All other divs shift down\n            const isOddColumn = col % 2 === 0; // Odd visual column (1st, 3rd, 5th...)\n\n            if (isOddColumn) {\n              // Odd columns: top disappears, reappears at bottom, others shift up\n              const topCard = colCards[0]; // Top card\n\n              colCards.forEach(card => {\n                if (card.id === topCard.id) {\n                  // Top card moves to bottom\n                  card.position.row = calculatedGridRows - 1;\n                  card.image = images[imageIndexRef.current++ % images.length];\n                } else {\n                  // All other cards shift up (row decreases)\n                  card.position.row = card.position.row - 1;\n                }\n              });\n            } else {\n              // Even columns: bottom disappears, reappears at top, others shift down\n              const bottomCard = colCards[colCards.length - 1]; // Bottom card\n\n              colCards.forEach(card => {\n                if (card.id === bottomCard.id) {\n                  // Bottom card moves to top\n                  card.position.row = 0;\n                  card.image = images[imageIndexRef.current++ % images.length];\n                } else {\n                  // All other cards shift down (row increases)\n                  card.position.row = card.position.row + 1;\n                }\n              });\n            }\n          }\n\n          return newCards;\n        });\n      }\n    };\n\n    animateGrid();\n  }, [images, controls, calculateGridDimensions]);\n\n  useEffect(() => {\n    window.addEventListener('resize', calculateGridDimensions);\n    return () => window.removeEventListener('resize', calculateGridDimensions);\n  }, [calculateGridDimensions]);\n\n  if (gridRows === 0 || gridCols === 0 || cardDimension === 0) {\n    return null; // Don't render until dimensions are calculated\n  }\n\n  return (\n    <div className=\"absolute inset-0 z-0 overflow-hidden bg-gray-900 flex items-center justify-center\">\n      <div\n        className=\"relative grid\"\n        style={{\n          gridTemplateColumns: `repeat(${gridCols}, ${cardDimension}px)`,\n          gridTemplateRows: `repeat(${gridRows}, ${cardDimension}px)`,\n          width: gridCols * cardDimension + (gridCols - 1) * CARD_GAP,\n          height: gridRows * cardDimension + (gridRows - 1) * CARD_GAP,\n          gap: CARD_GAP,\n        }}\n      >\n        {cardData.map((card) => (\n          <motion.div\n            key={card.key}\n            layout\n            transition={{ duration: ANIMATION_DURATION, ease: 'easeInOut' }}\n            className=\"relative bg-white rounded-lg shadow-lg flex items-center justify-center p-2 overflow-hidden\"\n            style={{\n              gridColumn: card.position.col + 1,\n              gridRow: card.position.row + 1,\n            }}\n          >\n            <img src={card.image} alt=\"Slideshow Card\" className=\"w-full h-full object-cover rounded-md\" />\n          </motion.div>\n        ))}\n      </div>\n      <div className=\"absolute inset-0 bg-black opacity-50 z-10\"></div>\n    </div>\n  );\n}"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,EAAEC,MAAM,EAAEC,WAAW,QAAQ,OAAO;AACvE,SAASC,MAAM,EAAEC,YAAY,QAAQ,eAAe;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAMrD,MAAMC,kBAAkB,GAAG,GAAG,CAAC,CAAC;AAChC,MAAMC,aAAa,GAAG,GAAG,CAAC,CAAC;AAC3B,MAAMC,QAAQ,GAAG,EAAE,CAAC,CAAC;;AASrB,eAAe,SAASC,mBAAmBA,CAAC;EAAEC;AAAiC,CAAC,EAAE;EAAAC,EAAA;EAChF,MAAMC,QAAQ,GAAGT,YAAY,CAAC,CAAC;EAC/B,MAAM,CAACU,QAAQ,EAAEC,WAAW,CAAC,GAAGhB,QAAQ,CAAS,EAAE,CAAC;EACpD,MAAMiB,aAAa,GAAGf,MAAM,CAAC,CAAC,CAAC;EAC/B,MAAMgB,UAAU,GAAGhB,MAAM,CAAC,CAAC,CAAC;EAC5B,MAAM,CAACiB,QAAQ,EAAEC,WAAW,CAAC,GAAGpB,QAAQ,CAAC,CAAC,CAAC;EAC3C,MAAM,CAACqB,QAAQ,EAAEC,WAAW,CAAC,GAAGtB,QAAQ,CAAC,CAAC,CAAC;EAC3C,MAAM,CAACuB,aAAa,EAAEC,gBAAgB,CAAC,GAAGxB,QAAQ,CAAC,CAAC,CAAC;EAErD,MAAMyB,uBAAuB,GAAGtB,WAAW,CAAC,MAAM;IAChD,MAAMuB,gBAAgB,GAAG,GAAG,CAAC,CAAC;IAC9B,MAAMC,gBAAgB,GAAG,GAAG,CAAC,CAAC;;IAE9B,MAAMC,cAAc,GAAGC,MAAM,CAACC,UAAU;IACxC,MAAMC,eAAe,GAAGF,MAAM,CAACG,WAAW;IAE1C,IAAIC,uBAAuB,GAAGP,gBAAgB;IAC9C,IAAIQ,kBAAkB,GAAGC,IAAI,CAACC,KAAK,CAACR,cAAc,IAAIK,uBAAuB,GAAGvB,QAAQ,CAAC,CAAC;IAC1F,IAAI2B,kBAAkB,GAAGF,IAAI,CAACC,KAAK,CAACL,eAAe,IAAIE,uBAAuB,GAAGvB,QAAQ,CAAC,CAAC;;IAE3F;IACA,IAAIwB,kBAAkB,GAAG,CAAC,IAAIG,kBAAkB,GAAG,CAAC,EAAE;MACpD,MAAMC,uBAAuB,GAAGH,IAAI,CAACC,KAAK,CAAER,cAAc,GAAGM,kBAAkB,GAAIxB,QAAQ,CAAC;MAC5F,MAAM6B,uBAAuB,GAAGJ,IAAI,CAACC,KAAK,CAAEL,eAAe,GAAGM,kBAAkB,GAAI3B,QAAQ,CAAC;MAC7FuB,uBAAuB,GAAGE,IAAI,CAACK,GAAG,CAACb,gBAAgB,EAAEQ,IAAI,CAACM,GAAG,CAACf,gBAAgB,EAAES,IAAI,CAACK,GAAG,CAACF,uBAAuB,EAAEC,uBAAuB,CAAC,CAAC,CAAC;IAC9I;;IAEA;IACAL,kBAAkB,GAAGC,IAAI,CAACC,KAAK,CAACR,cAAc,IAAIK,uBAAuB,GAAGvB,QAAQ,CAAC,CAAC;IACtF2B,kBAAkB,GAAGF,IAAI,CAACC,KAAK,CAACL,eAAe,IAAIE,uBAAuB,GAAGvB,QAAQ,CAAC,CAAC;;IAEvF;IACA,IAAIwB,kBAAkB,KAAK,CAAC,EAAEA,kBAAkB,GAAG,CAAC;IACpD,IAAIG,kBAAkB,KAAK,CAAC,EAAEA,kBAAkB,GAAG,CAAC;IAEpDb,gBAAgB,CAACS,uBAAuB,CAAC;IACzCX,WAAW,CAACY,kBAAkB,CAAC;IAC/Bd,WAAW,CAACiB,kBAAkB,CAAC;IAE/B,OAAO;MAAEA,kBAAkB;MAAEH,kBAAkB;MAAED;IAAwB,CAAC;EAC5E,CAAC,EAAE,EAAE,CAAC;EAENhC,SAAS,CAAC,MAAM;IACd,MAAM;MAAEoC,kBAAkB;MAAEH,kBAAkB;MAAED;IAAwB,CAAC,GAAGR,uBAAuB,CAAC,CAAC;IAErG,MAAMiB,YAAoB,GAAGC,KAAK,CAACC,IAAI,CAAC;MAAEC,MAAM,EAAER,kBAAkB,GAAGH;IAAmB,CAAC,EAAE,CAACY,CAAC,EAAEC,CAAC,MAAM;MACtGC,EAAE,EAAE9B,UAAU,CAAC+B,OAAO,EAAE;MACxBC,KAAK,EAAEtC,MAAM,CAACK,aAAa,CAACgC,OAAO,EAAE,GAAGrC,MAAM,CAACiC,MAAM,CAAC;MACtDM,QAAQ,EAAE;QAAEC,GAAG,EAAEjB,IAAI,CAACC,KAAK,CAACW,CAAC,GAAGb,kBAAkB,CAAC;QAAEmB,GAAG,EAAEN,CAAC,GAAGb;MAAmB,CAAC;MAClFoB,GAAG,EAAE,QAAQpC,UAAU,CAAC+B,OAAO,GAAG,CAAC;IACrC,CAAC,CAAC,CAAC;IACHjC,WAAW,CAAC0B,YAAY,CAAC;IAEzB,MAAMa,WAAW,GAAG,MAAAA,CAAA,KAAY;MAC9B,OAAO,IAAI,EAAE;QACX,MAAM,IAAIC,OAAO,CAACC,OAAO,IAAIC,UAAU,CAACD,OAAO,EAAEhD,aAAa,GAAG,IAAI,CAAC,CAAC;QAEvEO,WAAW,CAAC2C,SAAS,IAAI;UACvB,MAAMC,QAAQ,GAAG,CAAC,GAAGD,SAAS,CAAC;;UAE/B;UACA,KAAK,IAAIN,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGnB,kBAAkB,EAAEmB,GAAG,EAAE,EAAE;YACjD,MAAMQ,QAAQ,GAAGD,QAAQ,CAACE,MAAM,CAACC,IAAI,IAAIA,IAAI,CAACZ,QAAQ,CAACE,GAAG,KAAKA,GAAG,CAAC;;YAEnE;YACAQ,QAAQ,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAKD,CAAC,CAACd,QAAQ,CAACC,GAAG,GAAGc,CAAC,CAACf,QAAQ,CAACC,GAAG,CAAC;;YAExD;YACA;YACA;YACA;YACA;YACA;YACA,MAAMe,WAAW,GAAGd,GAAG,GAAG,CAAC,KAAK,CAAC,CAAC,CAAC;;YAEnC,IAAIc,WAAW,EAAE;cACf;cACA,MAAMC,OAAO,GAAGP,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;;cAE7BA,QAAQ,CAACQ,OAAO,CAACN,IAAI,IAAI;gBACvB,IAAIA,IAAI,CAACf,EAAE,KAAKoB,OAAO,CAACpB,EAAE,EAAE;kBAC1B;kBACAe,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAGf,kBAAkB,GAAG,CAAC;kBAC1C0B,IAAI,CAACb,KAAK,GAAGtC,MAAM,CAACK,aAAa,CAACgC,OAAO,EAAE,GAAGrC,MAAM,CAACiC,MAAM,CAAC;gBAC9D,CAAC,MAAM;kBACL;kBACAkB,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAGW,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAG,CAAC;gBAC3C;cACF,CAAC,CAAC;YACJ,CAAC,MAAM;cACL;cACA,MAAMkB,UAAU,GAAGT,QAAQ,CAACA,QAAQ,CAAChB,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;;cAElDgB,QAAQ,CAACQ,OAAO,CAACN,IAAI,IAAI;gBACvB,IAAIA,IAAI,CAACf,EAAE,KAAKsB,UAAU,CAACtB,EAAE,EAAE;kBAC7B;kBACAe,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAG,CAAC;kBACrBW,IAAI,CAACb,KAAK,GAAGtC,MAAM,CAACK,aAAa,CAACgC,OAAO,EAAE,GAAGrC,MAAM,CAACiC,MAAM,CAAC;gBAC9D,CAAC,MAAM;kBACL;kBACAkB,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAGW,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAG,CAAC;gBAC3C;cACF,CAAC,CAAC;YACJ;UACF;UAEA,OAAOQ,QAAQ;QACjB,CAAC,CAAC;MACJ;IACF,CAAC;IAEDL,WAAW,CAAC,CAAC;EACf,CAAC,EAAE,CAAC3C,MAAM,EAAEE,QAAQ,EAAEW,uBAAuB,CAAC,CAAC;EAE/CxB,SAAS,CAAC,MAAM;IACd4B,MAAM,CAAC0C,gBAAgB,CAAC,QAAQ,EAAE9C,uBAAuB,CAAC;IAC1D,OAAO,MAAMI,MAAM,CAAC2C,mBAAmB,CAAC,QAAQ,EAAE/C,uBAAuB,CAAC;EAC5E,CAAC,EAAE,CAACA,uBAAuB,CAAC,CAAC;EAE7B,IAAIN,QAAQ,KAAK,CAAC,IAAIE,QAAQ,KAAK,CAAC,IAAIE,aAAa,KAAK,CAAC,EAAE;IAC3D,OAAO,IAAI,CAAC,CAAC;EACf;EAEA,oBACEhB,OAAA;IAAKkE,SAAS,EAAC,mFAAmF;IAAAC,QAAA,gBAChGnE,OAAA;MACEkE,SAAS,EAAC,eAAe;MACzBE,KAAK,EAAE;QACLC,mBAAmB,EAAE,UAAUvD,QAAQ,KAAKE,aAAa,KAAK;QAC9DsD,gBAAgB,EAAE,UAAU1D,QAAQ,KAAKI,aAAa,KAAK;QAC3DuD,KAAK,EAAEzD,QAAQ,GAAGE,aAAa,GAAG,CAACF,QAAQ,GAAG,CAAC,IAAIX,QAAQ;QAC3DqE,MAAM,EAAE5D,QAAQ,GAAGI,aAAa,GAAG,CAACJ,QAAQ,GAAG,CAAC,IAAIT,QAAQ;QAC5DsE,GAAG,EAAEtE;MACP,CAAE;MAAAgE,QAAA,EAED3D,QAAQ,CAACkE,GAAG,CAAElB,IAAI,iBACjBxD,OAAA,CAACH,MAAM,CAAC8E,GAAG;QAETC,MAAM;QACNC,UAAU,EAAE;UAAEC,QAAQ,EAAE7E,kBAAkB;UAAE8E,IAAI,EAAE;QAAY,CAAE;QAChEb,SAAS,EAAC,6FAA6F;QACvGE,KAAK,EAAE;UACLY,UAAU,EAAExB,IAAI,CAACZ,QAAQ,CAACE,GAAG,GAAG,CAAC;UACjCmC,OAAO,EAAEzB,IAAI,CAACZ,QAAQ,CAACC,GAAG,GAAG;QAC/B,CAAE;QAAAsB,QAAA,eAEFnE,OAAA;UAAKkF,GAAG,EAAE1B,IAAI,CAACb,KAAM;UAACwC,GAAG,EAAC,gBAAgB;UAACjB,SAAS,EAAC;QAAuC;UAAAkB,QAAA,EAAAC,YAAA;UAAAC,UAAA;UAAAC,YAAA;QAAA,OAAE;MAAC,GAT1F/B,IAAI,CAACT,GAAG;QAAAqC,QAAA,EAAAC,YAAA;QAAAC,UAAA;QAAAC,YAAA;MAAA,OAUH,CACb;IAAC;MAAAH,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OACC,CAAC,eACNvF,OAAA;MAAKkE,SAAS,EAAC;IAA2C;MAAAkB,QAAA,EAAAC,YAAA;MAAAC,UAAA;MAAAC,YAAA;IAAA,OAAM,CAAC;EAAA;IAAAH,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OAC9D,CAAC;AAEV;AAACjF,EAAA,CAzJuBF,mBAAmB;EAAA,QACxBN,YAAY;AAAA;AAAA0F,EAAA,GADPpF,mBAAmB;AAAA,IAAAoF,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}