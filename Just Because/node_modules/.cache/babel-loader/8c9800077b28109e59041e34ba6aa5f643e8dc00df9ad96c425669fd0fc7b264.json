{"ast":null,"code":"var _jsxFileName = \"/Users/irenepaul/Documents/GitHub/Just-Because/Just Because/src/BackgroundSlideshow.tsx\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect, useRef } from 'react';\nimport { motion, useAnimation } from 'framer-motion';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst GRID_SIZE = 3; // 3x3 grid\nconst CARD_DIMENSION = 200; // Size of each card in pixels\nconst ANIMATION_DURATION = 2; // Seconds for one slide animation\n\nexport default function BackgroundSlideshow({\n  images\n}) {\n  _s();\n  const controls = useAnimation();\n  const [cardData, setCardData] = useState([]);\n  const imageIndexRef = useRef(0);\n  const gridRef = useRef(null);\n  useEffect(() => {\n    const initialCardData = Array.from({\n      length: GRID_SIZE * GRID_SIZE\n    }, (_, i) => ({\n      id: i,\n      image: images[imageIndexRef.current++ % images.length],\n      position: {\n        row: Math.floor(i / GRID_SIZE),\n        col: i % GRID_SIZE\n      }\n    }));\n    setCardData(initialCardData);\n    const animateGrid = async () => {\n      while (true) {\n        // Randomly choose to animate a row or a column\n        const isRow = Math.random() > 0.5;\n        const indexToAnimate = Math.floor(Math.random() * GRID_SIZE);\n\n        // Determine direction (left/right for row, up/down for column)\n        const direction = Math.random() > 0.5 ? 1 : -1; // 1 for forward, -1 for backward\n\n        const cardsToMove = cardData.filter(card => isRow ? card.position.row === indexToAnimate : card.position.col === indexToAnimate);\n\n        // Prepare for animation: move cards off-screen in the chosen direction\n        await Promise.all(cardsToMove.map(card => {\n          const newPos = isRow ? {\n            x: card.position.col * CARD_DIMENSION + direction * CARD_DIMENSION * GRID_SIZE,\n            y: card.position.row * CARD_DIMENSION\n          } : {\n            x: card.position.col * CARD_DIMENSION,\n            y: card.position.row * CARD_DIMENSION + direction * CARD_DIMENSION * GRID_SIZE\n          };\n          return controls.start({\n            x: newPos.x,\n            y: newPos.y,\n            transition: {\n              duration: 0\n            }\n          });\n        }));\n\n        // Update card data with new positions and images\n        setCardData(prevData => {\n          const newData = [...prevData];\n          const movedCards = [];\n          for (let i = 0; i < newData.length; i++) {\n            const card = newData[i];\n            if (isRow ? card.position.row === indexToAnimate : card.position.col === indexToAnimate) {\n              movedCards.push(card);\n            }\n          }\n          movedCards.forEach(card => {\n            let newCol = card.position.col;\n            let newRow = card.position.row;\n            if (isRow) {\n              newCol = (card.position.col + direction + GRID_SIZE) % GRID_SIZE;\n            } else {\n              newRow = (card.position.row + direction + GRID_SIZE) % GRID_SIZE;\n            }\n            card.position = {\n              row: newRow,\n              col: newCol\n            };\n            card.image = images[imageIndexRef.current++ % images.length];\n          });\n          return newData;\n        });\n\n        // Animate cards back into their new positions\n        await Promise.all(cardsToMove.map(card => {\n          return controls.start({\n            x: card.position.col * CARD_DIMENSION,\n            y: card.position.row * CARD_DIMENSION,\n            transition: {\n              duration: ANIMATION_DURATION,\n              ease: 'easeInOut'\n            }\n          });\n        }));\n        await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION * 1000)); // Wait for animation to complete\n      }\n    };\n    animateGrid();\n  }, [images, controls, cardData]);\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"absolute inset-0 z-0 overflow-hidden bg-gray-900 flex items-center justify-center\",\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      ref: gridRef,\n      className: \"relative\",\n      style: {\n        width: GRID_SIZE * CARD_DIMENSION,\n        height: GRID_SIZE * CARD_DIMENSION,\n        perspective: 1000 // For potential future 3D effects\n      },\n      children: cardData.map(card => {\n        return /*#__PURE__*/_jsxDEV(motion.div, {\n          className: \"absolute bg-white rounded-lg shadow-lg flex items-center justify-center p-2\",\n          style: {\n            width: CARD_DIMENSION,\n            height: CARD_DIMENSION,\n            x: card.position.col * CARD_DIMENSION,\n            y: card.position.row * CARD_DIMENSION\n          },\n          animate: controls,\n          children: /*#__PURE__*/_jsxDEV(\"img\", {\n            src: card.image,\n            alt: \"Slideshow Card\",\n            className: \"w-full h-full object-cover rounded-md\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 118,\n            columnNumber: 15\n          }, this)\n        }, card.id, false, {\n          fileName: _jsxFileName,\n          lineNumber: 107,\n          columnNumber: 13\n        }, this);\n      })\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"absolute inset-0 bg-black opacity-50 z-10\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 95,\n    columnNumber: 5\n  }, this);\n}\n_s(BackgroundSlideshow, \"ymD27GmRwgsmewTBxpxUrKyDIDY=\", false, function () {\n  return [useAnimation];\n});\n_c = BackgroundSlideshow;\nvar _c;\n$RefreshReg$(_c, \"BackgroundSlideshow\");","map":{"version":3,"names":["React","useState","useEffect","useRef","motion","useAnimation","jsxDEV","_jsxDEV","GRID_SIZE","CARD_DIMENSION","ANIMATION_DURATION","BackgroundSlideshow","images","_s","controls","cardData","setCardData","imageIndexRef","gridRef","initialCardData","Array","from","length","_","i","id","image","current","position","row","Math","floor","col","animateGrid","isRow","random","indexToAnimate","direction","cardsToMove","filter","card","Promise","all","map","newPos","x","y","start","transition","duration","prevData","newData","movedCards","push","forEach","newCol","newRow","ease","resolve","setTimeout","className","children","ref","style","width","height","perspective","div","animate","src","alt","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/irenepaul/Documents/GitHub/Just-Because/Just Because/src/BackgroundSlideshow.tsx"],"sourcesContent":["import React, { useState, useEffect, useRef } from 'react';\nimport { motion, useAnimation } from 'framer-motion';\n\ninterface BackgroundSlideshowProps {\n  images: string[];\n}\n\nconst GRID_SIZE = 3; // 3x3 grid\nconst CARD_DIMENSION = 200; // Size of each card in pixels\nconst ANIMATION_DURATION = 2; // Seconds for one slide animation\n\nexport default function BackgroundSlideshow({ images }: BackgroundSlideshowProps) {\n  const controls = useAnimation();\n  const [cardData, setCardData] = useState<Array<{ id: number; image: string; position: { row: number; col: number } }>>([]);\n  const imageIndexRef = useRef(0);\n  const gridRef = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    const initialCardData = Array.from({ length: GRID_SIZE * GRID_SIZE }, (_, i) => ({\n      id: i,\n      image: images[imageIndexRef.current++ % images.length],\n      position: { row: Math.floor(i / GRID_SIZE), col: i % GRID_SIZE },\n    }));\n    setCardData(initialCardData);\n\n    const animateGrid = async () => {\n      while (true) {\n        // Randomly choose to animate a row or a column\n        const isRow = Math.random() > 0.5;\n        const indexToAnimate = Math.floor(Math.random() * GRID_SIZE);\n\n        // Determine direction (left/right for row, up/down for column)\n        const direction = Math.random() > 0.5 ? 1 : -1; // 1 for forward, -1 for backward\n\n        const cardsToMove = cardData.filter(card => \n          isRow ? card.position.row === indexToAnimate : card.position.col === indexToAnimate\n        );\n\n        // Prepare for animation: move cards off-screen in the chosen direction\n        await Promise.all(cardsToMove.map(card => {\n          const newPos = isRow \n            ? { x: card.position.col * CARD_DIMENSION + direction * CARD_DIMENSION * GRID_SIZE, y: card.position.row * CARD_DIMENSION }\n            : { x: card.position.col * CARD_DIMENSION, y: card.position.row * CARD_DIMENSION + direction * CARD_DIMENSION * GRID_SIZE };\n          return controls.start({\n            x: newPos.x,\n            y: newPos.y,\n            transition: { duration: 0 },\n          });\n        }));\n\n        // Update card data with new positions and images\n        setCardData(prevData => {\n          const newData = [...prevData];\n          const movedCards = [];\n\n          for (let i = 0; i < newData.length; i++) {\n            const card = newData[i];\n            if (isRow ? card.position.row === indexToAnimate : card.position.col === indexToAnimate) {\n              movedCards.push(card);\n            }\n          }\n\n          movedCards.forEach(card => {\n            let newCol = card.position.col;\n            let newRow = card.position.row;\n\n            if (isRow) {\n              newCol = (card.position.col + direction + GRID_SIZE) % GRID_SIZE;\n            } else {\n              newRow = (card.position.row + direction + GRID_SIZE) % GRID_SIZE;\n            }\n            card.position = { row: newRow, col: newCol };\n            card.image = images[imageIndexRef.current++ % images.length];\n          });\n          return newData;\n        });\n\n        // Animate cards back into their new positions\n        await Promise.all(cardsToMove.map(card => {\n          return controls.start({\n            x: card.position.col * CARD_DIMENSION,\n            y: card.position.row * CARD_DIMENSION,\n            transition: { duration: ANIMATION_DURATION, ease: 'easeInOut' },\n          });\n        }));\n\n        await new Promise(resolve => setTimeout(resolve, ANIMATION_DURATION * 1000)); // Wait for animation to complete\n      }\n    };\n\n    animateGrid();\n  }, [images, controls, cardData]);\n\n  return (\n    <div className=\"absolute inset-0 z-0 overflow-hidden bg-gray-900 flex items-center justify-center\">\n      <div\n        ref={gridRef}\n        className=\"relative\"\n        style={{\n          width: GRID_SIZE * CARD_DIMENSION,\n          height: GRID_SIZE * CARD_DIMENSION,\n          perspective: 1000, // For potential future 3D effects\n        }}\n      >\n        {cardData.map((card) => {\n          return (\n            <motion.div\n              key={card.id}\n              className=\"absolute bg-white rounded-lg shadow-lg flex items-center justify-center p-2\"\n              style={{\n                width: CARD_DIMENSION,\n                height: CARD_DIMENSION,\n                x: card.position.col * CARD_DIMENSION,\n                y: card.position.row * CARD_DIMENSION,\n              }}\n              animate={controls}\n            >\n              <img src={card.image} alt=\"Slideshow Card\" className=\"w-full h-full object-cover rounded-md\" />\n            </motion.div>\n          );\n        })}\n      </div>\n      <div className=\"absolute inset-0 bg-black opacity-50 z-10\"></div>\n    </div>\n  );\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}